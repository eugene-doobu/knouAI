# 알고리즘 정의

주어진 문제를 풀기 위한 명령어들의 단계적 나열

- 입출력: 0개 이상의 외부 입력, 1개 이상의 출력
- 명확성: 각 명령은 모호하지 않고 단순 명확해야 함
- 유한성: 한정된 수의 단계를 거친 후에는 반드시 종료
- 유효성: 모든 명령은 컴퓨터에서 수행 가능해야 함

효율성: 실용적으로 사용할 수 있으면 효율적이어야 한다.

모든 문제에 대해서 적용할 수 있는 알고리즘은 없음.

주어진 문제, 속성, 조건 등이 매우 다양

대표적인 알고리즘 설계 방법
- 분할정복 방법 (2장)
- 동적 프로그래밍 방법 (3장)
- 욕심쟁이 방법 (4장)

## 알고리즘 분석

### 정확성 분석

- 유효한 입력, 유한 시간 => 정확한 결과 생성 여부
- 다양한 수학적 기법을 사용해서 이론적인 증명 필요

### 효율성 분석

- 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
- 메모리 양 -> 공간 복잡도 (정적 공간 +_동적 공간)
- 수행 시간 -> 시간 복잡도

### 시간 복잡도

- 구현한 알고리즘을 실행시켜 실제 수행 측정 -> 일반성이 결여! 안됨
- 시간 복잡도는 알고리즘의 단위 연산의 수행 횟수의 합으로 계산

시간 복잡도에 영향을 미치는 요인
- 입력 크기: 입력으로 제공되는 데이터의 크기, 문제가 해결하려는 대상이 되는 개체의 개수(행렬의 크기, 원소의 수, 그래프의 정점의 수)
- 입력 데이터의 상태

시간복잡도는 입력크기 n에 대한 함수 f(n)으로 표현

- 평균 수행 시간
- 최선 수행 시간
- 최악 수행 시간

### 점근 성능

실제로는 알고리즘의 성능을 비교할 때 점근 선능을 이용

- 입력 크기 n이 무한대로 커짐에 따라 결정되는 성능
- 입력 함수의 최고차항이 절대적인 영향을 미침

점근 성능의 결정 방법

- 수행 시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 표현

#### Big-oh 점근적 상한

함수 f와 g를 각각 양의 정수를 갖는 함수라 하자.

어떤 양의 상수 c와 n_0이 존재하여 모든 n>=n_0에 대하여 f(n)<=c*g(n)이면 f(n)=O(g(n))이다.

알고리즘 f(n)은 값이 아무리 커져도 O(g(n))을 넘길 수 없음.

- 최악의 수행 시간을 나타냄

#### Big-omega 점근적 하한

함수 f와 g를 각각 양의 정수를 갖는 함수라 하자.

어떤 양의 상수 c와 n_0이 존재하여 모든 n>=n_0에 대하여 f(n)>=c*g(n)이면 f(n)=Ω(g(n))이다.

함수가 아무리 빨라도 Ω(g(n))보다는 빨라 질 수 없음

- 최선의 수행 시간을 나타냄

#### Big-theta 점근적 상하한

함수 f와 g를 각각 양의 정수를 갖는 함수라 하자.

어떤 양의 상수 c와 n_0이 존재하여 모든 n>=n_0에 대하여 c_1*g(n) <= f(n) <= c_2*g(n)이면 f(n)=Θ(g(n))이다.

### 주요 O-표기 간의 연산 시간의 크기 관계

O: 최고 차항만 뽑아서 씀

상수시간 < 로그시간 < 선형시간 < 선형로그시간 < 제곱시간 < 세제곱시간 <지수시간

실용적인 방법으로는 그냥 반복문의 중첩 횟수를 셈


## 순환 알고리즘의 성능

- 점화식으로 표현
- 기본 점화식과 폐쇄형
- 2번(퀵정렬 최악), 3번(이진 탐색), 6번(합병정렬, 퀵정렬 최선)

# 정렬 알고리즘

주어진 데이터를 값의 크기 순서에 따라 배치하는 것

- 내부 정렬: 모든 데이터를 주기억장치에 저장한 후 정렬하는 방식
- 외부 정렬: 모든 데이터를 주기억장치에 저장할 수 없는 경우, 보조 기억장치를 이용하여 정렬하는 방법

## 내부 정렬 알고리즘

- 비교 기반 알고리즘: 버블, 선택, 삽입, 셸, 합병, 퀵, 힙
- 데이터 분포 기반 알고리즘: 계수, 기수

데이터 분포 기반 알고리즘은 성능이 O(n)으로 뛰어나지만, 미리 데이터의 성질을 알고 있어야 하므로 일반적으로 사용하기 힘들다.

## 기본 개념

### 안정적 정렬(stable)

동일한 값을 갖는 데이터가 여러 개 있을 때 정렬 전의 상대적인 순서가 정렬한 후에도 그대로 유지되는 정렬 방식

### 제자리 정렬(in-place)

입력 데이터를 저장한 공간 이외에 추가적인 저장 공간을 상수 개만 필요로 하는 정렬 방식

## 퀵 정렬(3강)

특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
- 오름차순으로 정렬한다고 가정

피벗
- 주어진 배열을 두 부분배열로 분할할 때 기준이 되는 특정 원소
- 보통 주어진 배열의 첫 번째 원소를 지정

### 개념와 원리

피벗이 제자리를 잡도록 하여 정렬하는 방식
- 한 번의 정렬 과정이 끝난 후, 피벗보다 작은 수는 전부 피벗의 왼쪽, 피벗보다 큰 수는 피벗의 오른쪽으로 이동
- 왼쪽 부분배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값
- 피벗을 나누는 파티션 함수가 핵심
- 배열의 마지막+1 원소에는 inf값이 있다고 가정

### 성능 분석

분할 함수 Partition() 수행 시간
- 피벗과의 비교 횟수
- 최악의 경우: O(n), 배열이 항상 0:n-1 또는 n-1:0으로 분할되는 경우, 이미 정렬되어 있는 경우
- 최선의 경우: O(logn)피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우. 피벗이 항상 중간값

피벗 선택의 임의성만 보장되면 평균 성능을 보일 가능성이 매우 높음

### 성능과 특징
- 최악 O(n^2) 평균 O(nlogn)
- 일반적으로 성능은 O(nlogn)으로 표현(피벗 선택의 임의성 보장)
- 제자리 정렬 알고리즘
- 안정적이지 않은 정렬 알고리즘

## 합병 정렬

전형적인 분할정복 방법이 적용된 알고리즘

### 합병 정렬의 전체적인 수행 과정

- 분할 정복 합병 과정

### 특징

- 최선, 최악, 평균 모두 nlogn
- 안정적인 정렬 알고리즘
- 제자리 정렬 알고리즘이 아님

## 힙 정렬

### 힙(heap)

- 완전 이진 트리
- 각 노드의 값은 자신의 자식 노드의 값보다 크거나 같다(최대힙)
- 임의의 값 삽입과 최댓값 삭제가 용이
- 내부적으로 배열로 표현

### 힙의 구현

- 왼쪽 자식 노드: 2i+1
- 오른쪽 자식 노드: 2i+2
- 부모 노드: floor(i-1/2)

### 개념과 원리

- 원소 추가시 가장 마지막에 추가한 후 재정렬
- 원소 삭제시 처음과 마지막을 변경한 후 삭제하고 재정렬

### 힙정렬을 위한 초기 힙 구축

1차원 배열을 힙으로 변경하는 과정

1. 주어진 입력 배열의 각 원소에 대해 힙에서의 삽입 과정을 반복
2. 주어진 입력 배열을 우선 완전 이진 트리로 만든 다음에 힙의 조건이 만족되도록 조정

### 특징

제자리 정렬 알고리즘
